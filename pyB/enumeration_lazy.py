from bexceptions import InfiniteSetLengthException
from config import USE_RPYTHON_CODE

if USE_RPYTHON_CODE:
     from rpython_b_objmodel import frozenset
     

def enumerate_cross_product(S,T):
    for x in S:
        for y in T:
            if USE_RPYTHON_CODE:
                yield W_Tuple((x,y))
            else:
                yield (x,y)  


# This generator returns one relation(-list) between S and T S<-->T.
# S and T can both be symbolic or explicit. If S or T is not finit enumerable, 
# this function throws an exception. It returns no frozensets because some check
# operations (e.g. function property) are more easy on lists.
# TODO: returning a symbolic set here is possible, but needs more tests an
# interpreter modification
# returntype: frozenset
def make_explicit_set_of_realtion_lists(S,T):   
    # card = |S|*|T|
    try:
        card = len(S)*len(T)
    except InfiniteSetLengthException:
        card = 0
    # empty relation
    yield frozenset([])
    # calc all permutations
    # XXX: Python pointer error 
    # 'error: no member named 'rbof_inst_lst' in 'struct pypy_rpython_b_objmodel_frozenset0'
    # caused by this code
    i=0
    while i!=card:
        for lst in _generate_relation(S,T, card=i+1, skip=0):
            assert len(lst)==i+1
            yield frozenset(lst) # removes double entries 
        i = i+1


# TODO: this is copy-pase from _generate_relation. Use Metha-programming to 
# to write generalization 
# returntype: list
def generate_powerset(S, card, skip):
    # yield one element of all combinations (x,y)
    if card==1:
        for element in S:
            if skip==0:
                yield [element]
            else:
               skip = skip -1
    # yield n elements of all combinations (x,y)
    else:
        assert card>1
        skip2 = 0
        for element in S:
            skip2 = skip2 +1
            if not skip==0:
                skip = skip -1
                continue
            for L in generate_powerset(S, card-1, skip2):
                if element in L:
                    continue
                res = L+[element]
                if len(res)==card:
                    yield res


# It is a helper only used by make_explicit_set_of_realtion_lists to generate 
# all combinations/sub-lists of length n.
# returntype: list of tuples
#
# e.g. {1,2}<->{True,False} =
# card 0:(1) {} (generated by caller)
# card 1:(4) {(1|->TRUE)} {(1|->FALSE)} {(2|->TRUE)} {(2|->FALSE)}
# card 2:(6) {(1|->FALSE),(1|->TRUE)} {(1|->FALSE),(2|->FALSE)} {(1|->FALSE),(2|->TRUE)} {(1|->TRUE),(2|->FALSE)} {(1|->TRUE),(2|->TRUE)} {(2|->FALSE),(2|->TRUE)}
# card 3:(4) {(1|->FALSE),(1|->TRUE),(2|->FALSE)} {(1|->FALSE),(1|->TRUE),(2|->TRUE)} {(1|->TRUE),(2|->FALSE),(2|->TRUE)} {(1|->FALSE),(2|->FALSE),(2|->TRUE)}
# card 4:(1) {(1|->FALSE),(1|->TRUE),(2|->FALSE),(2|->TRUE)} 
# cross product enumerator generates:  (1,TRUE), (1,FALSE), (2,TRUE), (2,FALSE)

def _generate_relation(S, T, card, skip):
    # yield one element of all combinations (x,y)
    if card==1:
        for element in enumerate_cross_product(S,T):
            if skip==0:
                yield [element]
            else:
               skip = skip -1
    # yield n elements of all combinations (x,y) (x:S y:T)
    else:
        assert card>1
        already_done = skip #number of elements which have been created in previous calls
        skip = 0
        
        for element in enumerate_cross_product(S,T):
            skip = skip +1
            # skip elements which can not create new combinations
            if not already_done==0:
                already_done = already_done -1
                continue
            
            # using this element a new combination can be created    
            for L in _generate_relation(S, T, card-1, skip):
                if element in L:
                    continue
                res = L+[element]
                if len(res)==card:
                    yield res