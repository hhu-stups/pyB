# -*- coding: utf-8 -*-
from config import MAX_OP_SOLUTIONS, MAX_SELECT_BRANCHES
from enumeration import try_all_values
from ast_nodes import *
from constrainsolver import calc_possible_solutions
from bexceptions import ValueNotInDomainException
from helpers import select_ast_to_list
from interp import exec_substitution


# returns list of (op_name, parameter_value_list, return_value_list, bstate) of all states
# TODO: implement filter MAX_NEXT_EVENTS
#
# Because the constraint-solver only can find approximations of correct parameters
# every solution generated by calc_possible_solutions musst be tested before the
# substitution can be added to the result list
def calc_next_states(env, bmachine):
    result = []
    if bmachine.aOperationsMachineClause:
        # WARNING: assumes no vars/sets with the same name in two b machines
        # TODO: write a method to check this 
        operations = env.all_operation_asts
        for op in operations:
            assert isinstance(op, AOperation)         
            # (1) add helper state to avoid sideeffects (dropped at the end of each iteration) 
            bstate = env.state_space.get_state().clone()
            env.state_space.add_state(bstate)  
            
            # (2) find parameter and return_val idNodes and add them to the frame
            parameter_idNodes  = op.children[op.return_Num : op.return_Num+op.parameter_Num]
            return_val_idNodes = op.children[0 : op.return_Num]
            # check lists
            for idNode in parameter_idNodes + return_val_idNodes:
                assert isinstance(idNode, AIdentifierExpression) # AST corruption  
            env.add_ids_to_frame([n.idName for n in parameter_idNodes + return_val_idNodes])
            env.push_new_frame(parameter_idNodes + return_val_idNodes)          
            #print "opname: \t", op.opName # DEBUG
            
            # (3.1) case one: no parameters
            substitution = op.children[-1]
            assert isinstance(substitution, Substitution)
            op_has_no_parameters = parameter_idNodes==[]   
            if op_has_no_parameters:
                exec_success = exec_substitution(substitution, env)
                if exec_success:
                    return_value_list = get_value_list(env, return_val_idNodes)
                    env.pop_frame()
                    bstate = env.state_space.get_state()                
                    result.append([op.opName, [], return_value_list, bstate])
                    env.state_space.undo()
                    continue 
            # (3.2) case two: find parameter values
            else:
                # This code uses the constraint solver an the top_level predicate to guess 
                # parameter values. Of course this guess can produce false values but it will 
                # never drop possible values
                # (3.2.1) find top_level predicate
                domain_generator = None
                if isinstance(substitution, APreconditionSubstitution):
                    predicate = substitution.children[0]
                    domain_generator = calc_possible_solutions(env, parameter_idNodes, predicate)
                # TODO: maybe more guesses elif... 
                else: # no guess possible, try all values 
                    domain_generator = calc_possible_solutions(env, parameter_idNodes, None)
                assert not domain_generator==None
                
                # Try solutions
                for solution in domain_generator:
                    try:
                        # use values of solution (iterations musst not affect each other):
                        bstate = env.state_space.get_state().clone()
                        env.state_space.add_state(bstate)  
                        set_parameter_values(env, parameter_idNodes, solution)
                        # try to exec
                        exec_success = exec_substitution(substitution, env)
                        if exec_success:
                            # Solution found!                          
                            # (3.2.2) get parameter and return-value solutions
                            parameter_value_list = get_value_list(env, parameter_idNodes)
                            return_value_list    = get_value_list(env, return_val_idNodes)
                            env.pop_frame() # pop on the cloned state
                            bstate = env.state_space.get_state().clone()
                            result.append([op.opName, parameter_value_list, return_value_list, bstate])
                    except ValueNotInDomainException:
                        pass #TODO: modify enumerator not to generate that "solutions" at all
                    env.state_space.undo()
            env.state_space.undo()
    if result==[]:
        print "WARNING: Deadlock!"
    # alphabetic sort of results
    result = sorted(result, key = lambda state: state[0])
    return result


def set_parameter_values(env, parameter_idNodes, solution):
	for name in [x.idName for x in parameter_idNodes]:
		value = solution[name]
		env.set_value(name, value)


def get_value_list(env, idNode_list):
    value_list = []
    for name in [x.idName for x in idNode_list]:
        value = env.get_value(name)
        value_list.append(tuple([name, value]))
    return value_list