Package de.prob.animationscript.parser;

/*******************************************************************
 * Helpers                                                         *
 *******************************************************************/
Helpers

	underscore = '_';
    at = '@';
    lf = 10;
    cr = 13;
    space = ' ';
    slash = '/';
    double_quote = '"';
    quote = ''';
    star = '*';
    colon = ':';
    lpar = '(';
    rpar = ')';
    
    small_letter =  ['a'..'z'];
    capital_letter = ['A' .. 'Z'];
    letter = small_letter | capital_letter;
    digit = ['0' .. '9'] ;

	mode = 'nodes' |'operation'|'transition'|'uncovered'
			|'NODES' |'OPERATION'|'TRANSITION'|'UNCOVERED'
			|'Nodes'|'Operation'|'Transition'|'Uncovered';
	
	reduction = 'no_reduction'|'nauty'|'permutation'|'marker';
	
	setting = 'breadth_first' |'deadlocks'|'invariant';
	
	starting = 'init_states'|'current_state'|'as_init';
	
    comment_start = slash slash;
	line_break = [lf + cr];
	
	layout_char = [[[[0 .. 32] - line_break] + [127..160]] + [[8206 .. 8207] + [8232 .. 8233]]];
	all_chars = [0 .. 0xffff];
	all_string_chars = [[[[[[[all_chars - layout_char] - at] - slash] -line_break] -double_quote] + space] -quote];
	
	param_chars = [[all_string_chars - rpar] - lpar];
	identifier = ('$' | letter) (letter | digit | underscore)*;
    

/*******************************************************************
 * States                                                          *
 *******************************************************************/
States

	normal,
	string,
	comment,
	param;

/*******************************************************************
 * Tokens                                                          *
 *******************************************************************/

Tokens

// single line comments
	{normal -> comment} comment_start = comment_start;
	{comment} comment = [all_chars - line_break]*;
	{comment -> normal} comment_end = line_break;
	
// keywords
	{normal} language 	= '@language';
	{normal} seed		= '@seed';
	{normal} settings	= '@settings';
	{normal} assert 	= '@assert';
	{normal} load 		= '@load';
	{normal} enabled 	= '@enabled';
	{normal} disabled 	= '@disabled';
	{normal} statistic 	= '@statistic';
	{normal} coverage 	= '@coverage';
	{normal} getseed 	= '@getSeed';
	{normal} invariant 	= '@invariant';
	{normal} consistency 	= '@consistencyCheck';
	{normal} ltl 	= '@LTLcheck';
	
	{normal} setting 	= setting;
	{normal} starting 	= starting;
	{normal} reduction 	= reduction;
	
	{normal} mode 		= mode;
	{normal} switch		= 'on'|'On'|'ON'|'off'|'Off'|'OFF';
	
	{normal} opname		= identifier;
	{normal} char		= letter;
	{param, normal} number = digit+;
	{param, normal} colon = colon;
	
	{normal -> string, string -> normal} string_delimiter = double_quote | quote;
	{string} string 	= all_string_chars*;
	
	{param, normal -> param} param_begin	= lpar;
	{param} param_end						= rpar;
	{param} param_string 					= param_chars*;
	
	{normal} line_break = line_break;
	{normal} white_space = layout_char;


/*******************************************************************
 * Ignored Tokens                                                  *
 *******************************************************************/
Ignored Tokens

	white_space,
	string_delimiter,
	comment_start,
	comment;

/*******************************************************************
 * Productions                                                     *
 *******************************************************************/
Productions

	parse_unit {-> parse_unit} =
		[definitions]:definitions? [statements]:statements? 
		{->New parse_unit([definitions.definition], [statements.statement])};
	
	definitions {-> definition*} = definition_list line_break+ {-> [definition_list.definition]};
	
	statements {-> statement*} = [statements]:statement_list line_break* {-> [statements.statement]}; 
	
	definition_list {-> definition*} = 
		{single} definition {-> [definition]}|
		{multi} [list]:definition_list line_break+ [single]:definition {-> [list.definition, single.definition]};
	
	definition {-> definition} =
		 {language} P.language{-> language.definition}|
		 {invariant} P.invariant{-> invariant.definition}|
		 {seed} P.seed{-> seed.definition};
	
	language {-> definition} = 
		T.language [lang]:string{->New definition.language(lang)};
		
	invariant {-> definition} =
		T.invariant [parameter]:param_plain{->New definition.invariant(parameter.parameter)};
		
		
	seed {-> definition} =
		T.seed [p1]:number [c1]:colon [p2]:number [c2]:colon [p3]:number [c3]:colon [p4]:number 
		{->New definition.seed(p1,p2,p3,p4)};
		
		
	statement_list {-> statement*} = 
		{single} statement {-> [statement]}|
		{multi} [list]:statement_list line_break+ [single]:statement 
		{-> [list.statement, single.statement]};
		
	statement {-> statement} =
		 {settings} P.settings{-> settings.statement}|
		 {assert} P.assert{-> assert.statement}|
		 {load} P.load{-> load.statement}|
		 {enabled} P.enabled{-> enabled.statement}|
		 {disabled} P.disabled{-> disabled.statement}|
		 {coverage} P.coverage{-> coverage.statement}|
		 {get_seed} P.get_seed{-> get_seed.statement}|
		 {consistency} P.consistency{-> consistency.statement}|
		 {ltl} P.ltl{-> ltl.statement}|
		 {opcall} P.opcall{-> opcall.statement};

	assert {-> statement} = 
		T.assert [parameter]:param_plain {->New statement.assert(parameter.parameter)};
	
	settings {-> statement} =
		T.settings [name]:string [value]:string {->New statement.settings(name, value)};

	load {-> statement} =
		T.load [project]:string [maschine]:string {->New statement.load(project, maschine)};
		
	enabled {-> statement} =
		T.enabled [opname]:opname [parameter]:param_plain?{->New statement.enabled(opname, parameter.parameter)};
		
	disabled {-> statement} =
		T.disabled [opname]:opname [parameter]:param_plain?{->New statement.disabled(opname, parameter.parameter)};
		
		
	coverage {-> statement} =
		T.coverage mode?{->New statement.coverage(mode)};
		
	get_seed {-> statement} =
		T.getseed {->New statement.get_seed()};
	
	consistency {-> statement} =
		T.consistency [set1]:setting? [set2]:setting? [set3]:setting? [reduction]:reduction?
		{->New statement.consistency(set1,set2,set3,reduction)};
	
	ltl {-> statement} =
		T.ltl [parameter]:param [start]:starting? [reduction]:reduction?
		{->New statement.ltl(parameter.parameter, start, reduction)};

	opcall {-> statement} =
		[opname]:T.opname [parameter]:param? {->New statement.opcall(opname, parameter.parameter)};
		
	param {-> parameter} = 
		{plain} P.param_plain  {-> param_plain.parameter};
		
		
	param_plain {-> parameter} = 
		T.param_string {->New parameter.plain(param_string)};
		
	
/*******************************************************************
 * Abstract Syntax Tree                                            *
 *******************************************************************/
Abstract Syntax Tree

	parse_unit = definition* statement*;
	
	definition =
		{language} 	[language]:string|
		{invariant}	[parameter]:parameter|
		{seed} 		[number1]:number [number2]:number [number3]:number [number4]:number;
	
	statement = 
		{assert} 	[parameter]:parameter|
		{settings}	[name]:string [value]:string|
		{load}		[project]:string [machine]:string|
		{enabled}	[opname]:opname [parameter]:parameter?|
		{disabled}	[opname]:opname [parameter]:parameter?|
		{coverage}	[mode]:mode?|
		{get_seed}	|
		{consistency}	[set1]:setting? [set2]:setting? [set3]:setting? [reduction]:reduction? |
		{ltl}		[parameter]:parameter [start]:starting? [reduction]:reduction?|
		{opcall}	[opname]:opname [parameter]:parameter?;
		
	parameter = 
		{plain}		[param]:param_string;
