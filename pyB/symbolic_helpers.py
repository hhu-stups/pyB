from bexceptions import InfiniteSetLengthException
from config import USE_RPYTHON_CODE
from helpers import enumerate_cross_product

if USE_RPYTHON_CODE:
     from rpython_b_objmodel import frozenset
     
# helper functions for symbolic set operations

# True:  these predicates are syntacticly equal
# True examples:
# {x|x:NAT}=={y|y:NAT}
# False: these predicates are unequal
# no false cases yet implemented
# Exception: I dont know if they are equal (likely case)
# DontKnow examples: 
# {x|x>3 & x<5}=={y|y=4}
# {x|x:NAT & x<200}=={y|y<200 & y:NAT}
# {x|x:INTEGER & x>=0 }=={y|y:NATURAL}
# returntype: boolean
def check_syntacticly_equal(predicate0, predicate1):
    if predicate0.__class__ == predicate1.__class__:
        try:
            length = range(len(predicate0.children))
        except AttributeError:
            return True #clase check was successful and no more children to check
        for index in length:
            child0 = predicate0.children[index]
            child1 = predicate0.children[index]
            if not check_syntacticly_equal(child0, child1):
                return False
        return True
    else:
        message = "ERROR: failed to check if predicates are equal: '%s' and '%s'" %(pretty_print(predicate0),pretty_print(predicate1))
        print message
        raise DontKnowIfEqualException(message)
        return False


# This generator returns one relation(-list) between S and T S<-->T.
# S and T can both be symbolic or explicit. If S or T is not finit enumerable, 
# this function throws an exception. It returns no frozensets because some check
# operations (e.g. function property) are more easy on lists.
# TODO: returning a symbolic set here is possible, but needs more tests an
# interpreter modification
# returntype: frozenset
def make_explicit_set_of_realtion_lists(S,T):   
    # card = |S|*|T|
    try:
        card = len(S)*len(T)
    except InfiniteSetLengthException:
        card = 0
    # empty relation
    yield frozenset([])
    # calc all permutations
    # XXX: Python pointer error 
    # 'error: no member named 'rbof_inst_lst' in 'struct pypy_rpython_b_objmodel_frozenset0'
    # caused by this code
    i=0
    while i!=card:
        for lst in _generate_relation(S,T, card=i+1, skip=0):
            assert len(lst)==i+1
            yield frozenset(lst) # removes double entries 
        i = i+1


# TODO: this is copy-pase from _generate_relation. Use Metha-programming to 
# to write generalization 
# returntype: list
def generate_powerset(S, card, skip):
    # yield one element of all combinations (x,y)
    if card==1:
        for element in S:
            if skip==0:
                yield [element]
            else:
               skip = skip -1
    # yield n elements of all combinations (x,y)
    else:
        assert card>1
        skip2 = 0
        for element in S:
            skip2 = skip2 +1
            if not skip==0:
                skip = skip -1
                continue
            for L in generate_powerset(S, card-1, skip2):
                if element in L:
                    continue
                res = L+[element]
                if len(res)==card:
                    yield res


# It is a helper only used by make_explicit_set_of_realtion_lists to generate 
# all combinations/sub-lists of length n.
# returntype: list of tuples
#
# e.g. {1,2}<->{True,False} =
# card 0:(1) {} (generated by caller)
# card 1:(4) {(1|->TRUE)} {(1|->FALSE)} {(2|->TRUE)} {(2|->FALSE)}
# card 2:(6) {(1|->FALSE),(1|->TRUE)} {(1|->FALSE),(2|->FALSE)} {(1|->FALSE),(2|->TRUE)} {(1|->TRUE),(2|->FALSE)} {(1|->TRUE),(2|->TRUE)} {(2|->FALSE),(2|->TRUE)}
# card 3:(4) {(1|->FALSE),(1|->TRUE),(2|->FALSE)} {(1|->FALSE),(1|->TRUE),(2|->TRUE)} {(1|->TRUE),(2|->FALSE),(2|->TRUE)} {(1|->FALSE),(2|->FALSE),(2|->TRUE)}
# card 4:(1) {(1|->FALSE),(1|->TRUE),(2|->FALSE),(2|->TRUE)} 
# cross product enumerator generates:  (1,TRUE), (1,FALSE), (2,TRUE), (2,FALSE)

def _generate_relation(S, T, card, skip):
    # yield one element of all combinations (x,y)
    if card==1:
        for element in enumerate_cross_product(S,T):
            if skip==0:
                yield [element]
            else:
               skip = skip -1
    # yield n elements of all combinations (x,y) (x:S y:T)
    else:
        assert card>1
        already_done = skip #number of elements which have been created in previous calls
        skip = 0
        
        for element in enumerate_cross_product(S,T):
            skip = skip +1
            # skip elements which can not create new combinations
            if not already_done==0:
                already_done = already_done -1
                continue
            
            # using this element a new combination can be created    
            for L in _generate_relation(S, T, card-1, skip):
                if element in L:
                    continue
                res = L+[element]
                if len(res)==card:
                    yield res